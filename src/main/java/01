제 1 강 스프링의 소개 - pdf랑 같이 할것
스프링은 웹뿐만이 아니라 서버단에서 이루어진

비침투적인 방식과 POJO 으로 해서 결합도를 낮추고 응집도를 낮추는
	기술을 썼는데 그 기술이 코드로 들어가지 않는 기능

Spring 
	★Core 기능 
	★AOP기능 - 관심지향프로그램이라해서 일부 지원

	JMX - 모니터링
	JCA - 메시지 보내는 

로컬에서는 다른 컴포넌트를 담는

WEB에서는 객체를 만들 수 있는게 컨테이너

※ Spring Core
	제어의 역전을 담당하는 (IoC)
	
스프링은 왜 프레임워크라고 하냐? 
	모든 프레임워크는 IoC(Invasion of Control : 제어의 역전)을 갖고 있는거를 프레임워크
	제어권이 컴퓨터에 있다 -> 제어의 역전이라고 한다 
		개발자가 주체가 아닌 프레임워크가 시키는 -> 어느 순간 완성이 되어있는
		지가 시키는 나한테 -> 스프링의 근간이 되는 게 core에 있다
		BeanFactory를 기반으로 Bean 클래스들을 제어할 수 있는 기능을 지원
		컴퓨터가 뭘 만들어야 된다고 시키는 -> 싫은데 안 만들건데 그럼 에러

※ Spring Context - 큰 환경

※ AOP (Aspect Oriented Programming) - 관점(관심) 지향 프로그래밍
	객체지향에서 근간

	메서드에서 종료를 보고 싶을때 
		메서드 종료 시작을 이렇게 써야 하는데 
		객체지향에서는 메서드를 추가할때마다 중복 코드가 늘어나게 됨

	=> 관심지향이 나옴
		-> 니가 하고 싶은게 뭐야?? 
		Business Logic을 만드는

		실행할때 적용되서 자동으로 들어가는 -> 일일이 쓸 필요가 없다
			JSP에서 include지시어를 해놓으면 걔가 나중에 합쳐지는(위빙하고 비슷)
			그럼 내가 매번쓰지 않아도 된다

※ JCA - 로그

※ Portley MVC - Portlet서버에서 이루어진
----------------------------------------------------------------------------------------------------------------

새로운거를 할때 JDK11을 할 수도 있다
기존의 거를 하더라도 업그레이드를 해서 할 수도 있다

11버전이 공식버전이고 15번 버전, 등 계속 안정화가 되면 11에 들어오는
근데 왜 8번을 쓰냐?? 그 예전엔 8이 11의 기능

11은 8과 달리 모듈이라는 개념이 들어간다

톰캣은 지금도 9번전 많이 쓴다

이클립스 늘 최신판을 받지 마라 -> 써드파티 때문 플러그인 호환이 안될 수 있다
----------------------------------------------------------------------------------------------------------------
스프링 모듈 다운받기
https://repo.spring.io/release/org/springframework/spring/5.3.4/에서 dist.zip 파일을 받으면 된다

스프링 모듈의 구성 - pdf에서 확인

스프링 모듈간의 의존 관계
	무조건 Core까지 가야한다
만약에 JDBC를 넣어야 한다 
	-> JDBC, Transaction, Context, Beans, Core는 들어가야 JDBC기능을 쓸 수 있다

하다보면 자연스럽게 뭐뭐 들어가야해라고 알 수는 있다

이러한 의존관계를 관리해주는게 Maven 
	스프링은 기본적으로 메이븐이 설치가 되어있다

스프링 첫 번째 예제 따라하기
+ : public이라는 의미

편의성을 위해서 웹으로 만들고 로컬로

HelloSpring을 썼는데 이게 정말 올바른 구조냐??
	HelloSpring과 MyBean이 결합도가 강하다
	=> 고쳐야 할게 100개있다 그럼 환장하는 거지

	=> 그래서 어떻게 할거냐? 
		그래서 자주 변경해야 하는 어플리케이션이 위와 같은 어플리케이션에서 쓴다면 코드를 대폭 수정

	=> 다형성을 이용해서 결합도를 낮추는

※ 예제 2 
	기존의 클래스(코드)를 건드리지 않고 새로운 기능을 추가
	실행할때 바꿔치기 하면 된다
	
	왜 중요하냐? 
		예를 들어서 원자력 관리 시스템을 운영하고 있는
		원자력이 위험한데 코드를 다 뜯어 고칠거냐??
			미치는거지 -> 이런 사건이 없냐? -> 원래 우편번호가 6자리 -> 5자리로 바뀜
					주소도 원래주소에서 도로명으로 바뀜
						=> 이러한게 4-5년
	=> 기존 코드를 안건드리고 새로운 기능을 추가했다
	결합도가 낮은 프로그램의 강점이 된다
	
	-> 그런데 문제점
		결국 new 를 이용해서 객체를 생성하니까 새로운 기능으로 다 바꿔줘야 하는
		=> 이걸 안 할 수 없냐?
		=> new 자체가 엄청난 결합
		=> 스프링가면 new를 안함

	name은 new를 안했는데 왜 하냐?? 
		누군가 넣어줬다 -> 그걸 뭐라그러냐면 DI(의존성 주입 : Dependency Injection)
		이러한 비슷한게 Factory 패턴 객체만 넘겨주는

※ 3단계 (스프링 프레임워크)
	스프링 설정 파일에 다가 뭔가를 써주면 필요에 맞춰서 설명해주겠다

	기본적인 이름이 applicationContext.xml
	
	help -> install New Software -> Add.. -> Name은 원하는거, 
		location : https://dist.springsource.com/snapshot/TOOLS/nightly/e4.16 -> Add
		-> select all -> Next해서 설치 해줘야 한다

	<bean id="myBean" class="tommy.spring.exam02.MyBeanOne"></bean>
	MyBean myBean = new  MyBeanOne();가 같음

	기존 코드를 건드리지 않고 새로운 기능으로 바꿔치기

	설정파일에서 기능을 바꿈
		-> 자바 소스 코드를 안건드림

	인터페이스 기반의 설계와 스프링을 활요함으로써 소스파일은 변경하지 않고 스프링 설정파일만 변경해서 다양한 객체를 생성하는
----------------------------------------------------------------------------------------------------------------
제 2 강 프레임워크의 개요

① 초 난감 DAO 
	반복되는 것 문제
	예외처리 문제 
	드라이버 로딩하고 커넥션 연결하고
	쿼리문이 조금 바뀌면 소스를 고쳐야 한다
	...

② DAO의 분리
	첫번째 접근 : 관심사의 분리(객체지향의 첫번째 방법론)
		위와 같이 하면 변화에 대응이 안된다.
	결합도는 낮추고 응집도는 높이고

	1. DB와 연결을 어떻게 할거냐?
	2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
	3. 작업이 끝나면 사용한 리소스인 Statement와 Connection을 닫아줘서 소중한 공유 리소스를 시스템에게 돌려주는 것

	기능에는 영향을 주지 않으면서 코드의 구조만 바꾸는 -> 리펙토링
		메서드 추출기법이라고 한다 -> 메서드를 추출해서 중복 코드를 없애는

	상속을 통한 확장 기법으로 한번더 분리

디자인 패턴 : 쓰고있는거를 다 정리를해서 20몇개 를 디자인 패턴
	패턴 : 소프트웨어를 개발 할때 여러가지 문제에 대한 검증받은 솔루션

템플릿 메서드 패턴 : 상속을 통해 슈퍼클래스의 기능을 확장할때 사용하는 방법. 슈퍼클래스에서
	디폴트 기능을 정의해 두거나 비워두었다가 서브클래스에서 선택적으로 오버라이드 할 수 있게 
	만들어둔 메서드를 훅 메서드

팩토리 메서드 패턴 : 상속을 통해 기능을 확장하게 하는 패턴. 슈퍼클래스 코드에서는 서브클래스
	에서 구현할  메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용
	이때 주로 인터페이스 타입으로 리턴

	상속의 문제 자바에서는 다중 상속을 허락하지 않는다
		이미 결합도가 높아져버림
	그래서 상속이 꼭 좋은게 아니다
	-> DAO를 독립된 클래스로 분리를 해보자

	느슨한 연결고리를 만들어보자 -> 인터페이스로 
	
	인터페이스로 주면 다중상속의 문제점에 안걸린다
	상속받았다고 해도 다형성을 해서 그나마 느슨한 관계

	new를 안할 수 없을까

※ 관계설정과 책임의 분리
	관계가 만들어질려면 만들어진 객체가 있어야 하는
	
	만들어서 넣어주면 난 사용만 하면 되잖아??
	
	스프링이 컨테이너 객체를 생성하는 기능

	나는 만드는 방법을 몰라도 되는

	클래스 사이에 동적인 관계가 만들어진 

※ 객체지향 설계의 원칙 (SOLID)
	확장에는 열려있어야 하고 
	기존 소스를 안 건들리고 (변경에는 닫혀있엉햐 한다) -> OCP(The OPen Closed Principle) :개방 폐쇄 원칙

	 SRP : 단일 책임의 원칙

	LSP ; 리스코프 치환 원칙
		참조되는 기반클래스의 함수는 파생클래스 객체의 상세를 알지 않고서도 사용될 수 있어야한다
	ISP 인터페이스 분히 원칙
	DIP 의존 관계 역전 원칙

	★★★★★★★★핵심은 응집도는 높게 결합도는 낮게

※ 전략패턴 
자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즈을 인터페이스를 통해 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘
-> 설정에서 바꾸는

※ 프레임워크의 개요
아키텍처 와 골격코드 
전체 구조에 대한거를 프레임워크가 제공

아키텍쳐의 일관성이 잘 유지
문서를 보고 하기 때문에 일관성이 유지된다
	문제는 개발할때가 아닌 유지보수 과정에서 산출물이 무시되고 개발자들의 경험에 의존하여 유지보수가 진행되는 경우
	애플리케이션의 기본 아키텍처는 프레임워크가 제공, 그뼈대에 살을 붙이는 작업만 개발자가 하는 것

※ 프레임워크의 장점
빠른 구현 시간
쉬운관리
개발자들의 역량 획일화
검증된 아키텍처의 재사용과 일관성 유지

스프링은 웹만 만드는게 아닌 큰 틀

----------------------------------------------------------------------------------------------------------------

스프링 프레임 워크의 특징
경량 프레임 워크

제어의 역행

관심지향 프로그래밍(AOP)

계좌이체 / 입출금 / 이자계산-> 핵심 관심

	로깅 / 보안 / 트렌젝션 -> 없어도 되는데 문제들이 터졌을때 은행등리 증명하려고
		모두가 정직하다면 로그가 필요하다 -> 횡단관심
	응집도가 높게

컨테이너 : 객체간의 의존관계 관리
	스프링 자체가 컨테이너


서블릿 코드 어디를 살펴보아도 객체를 생성하는게 존재하지 않는다는 것 -> 우린 객체를 직접 만든적이없다 
-> 아무리 찾아봐도 객체 생성하는 코드가 존재하지 않는다 -> 누가 했냐? 서블릿 컨테이너
웹에서 지가 객체를 만들어준게 컨테이너

제어의 역행이라는 개념은 일련의 작업들을 소스코드로 처리하지 않고 컨테이너에서 처리하는 것을 의미
-> 비 침투적인 방식 -> 낮은 결합도

커플링(Couplling)가 높은 프로그램(결합도가 높은)
	하나 바붰는데 사이드 이펙트로 에러가 나는
	

세번째 패키지가 ContextPath가 된다
폴더구조가 메이븐 폴더구조

pom.xml 메이븐 설정파일
spring version을 

<org.springframework-version>5.3.4</org.springframework-version>
-> 꼭 바꿔야 하는

-> 꼭 안바꿔도 되지만 최신버전을 쓰고 싶을때
<org.aspectj-version>1.9.6</org.aspectj-version>
<org.slf4j-version>1.7.30</org.slf4j-version>

톰캣 9.0은 4.0.0까지만 지원

<dependency>
	<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>4.12</version>
	<scope>test</scope>
</dependency>  
얘는 무조건 바꿔야 하는

<plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>

스프링 버전 junit버전 위는 무조건 바꿔줘야 한다

----------------------------------------------------------------------------------------------------------------
스프링은 applicationContext.xml에 있는 xml을 읽어서 바꿔주는

객체를 new를 안해도 쓸 수 있는

독립적인 어플리케이션이 되는

핵심은 기존의 코드를 수정하지 않고 새로운 기능을 변경 할 수 있는
소스코드를 고치지 않고 새로운 기능을 추가하는

기존꺼는(소스코드) 그대로 두고 새롭게 기능을 추가하는게 필요할때  

=> 이런 기능이 엔터프라이즈 시스템에서 무조건 되야 한다
	
내일부터 IOC부터 해서 스프링의 DI기능을 볼거임

	
		 






