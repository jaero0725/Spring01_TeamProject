제 3 강 Spring DI

Spring Bean 컨테이너는 
	bean factoiry 
	application context
	web application context 
	이렇게 세가지 컨테이너가 있다

스프링 컨테이너에 저장되는 빈 객체는 최소한 생성, 초기화, 소멸의 라이프 사이클을 갖게 됨

빈 객체의 라이프 사이클
 Ⓐ BeanNameAware.setBeanName()★
 Ⓑ BeanFactoryAware.setBeanFactory()★
 Ⓒ BeanPostProcessor의 초기화 전처리
 Ⓓ 커스텀 init-method
 Ⓔ InitializingBean.afterPropertiesSet()★
 Ⓕ BeanPostProcessor의 초기화 후처리
 Ⓖ 이제는 빈 객체를 얻었다. 이 빈 객체를 사용한다.
 Ⓗ DisposableBean.destroy()★
 Ⓘ 커스텀 destory-method

Ⓒ, Ⓕ 단계 : 빈 클래스가 아닌 특수 빈을 통해 처리되는 과정.
실제로 빈 객체를 얻는 것은  Ⓖ에서 
=> 이런 흐름으로 간다지 외울 순 없다

ApplicationContext를 사용하는 경우 추가되는 라이프 사이클
 Ⓐ BeanNameAware.setBeanName()
 Ⓑ BeanFactoryAware.setBeanFactory()
 Ⓒ ResourceLoaderAware.setResourceLoader()
 Ⓓ ApplicationEventPublisherAware.setApplicationEventPublisher()
 Ⓔ MessageSourceAware.setMessageSource()
 Ⓕ ApplicationContextAware.setApplicationContext()
 Ⓖ @PostConstruct 메소드 실행
 Ⓗ BeanPostProcessor의 초기화 전처리
 Ⓘ 이제는 빈 객체를 얻었다. 이 빈 객체를 사용한다.
 Ⓙ @PreDestory 메소드 실행
 Ⓚ DisposableBean.destroy()
 Ⓛ 커스텀 destory-method

자원 및 메시지 처리, 이벤트 처리 등 추가적인 기능을 빈이 사용할 수 있도록 단계 추가

인터페이스이름. 메서드 이름 

※ BeanNameAware 인터페이스
	빈 객체가 자기 자신의 이름을 알아야 하는 경우에 사용

※ BeanFactoryAware 인터페이스와 ApplicationCOntextAware 인터페이스 
	빈 객체가 스프링 컨테이너를 직접 사용해야 할 필요가 있을 경우

※ InitioalizingBean인터페이스 
	주로 빈 객체의 프로퍼티가 모두 올바르게 설정되었는지의 여부를 검사하는 용도로 사용

※ DispodableBean
	빈 객체를 컨테이너에서 제서하기 전에 정의된 메서드를 호출하여 빈 객체가 자원을 반납할 수 있도록 함

실무에서는 beanFactory는 실무에서 안쓴다

오라클 드라이버는 라이센스가 있어서 오라클 홈페이지에서 받아야 한다
pom.xml에서 설정하는 거는 
	jar파일을 가져오는 원리가 MVNrepository공용에서 가지고 온 것
	우선적으로 내컴퓨터에서 받고
	그게 없으면 서버에서 받고 
	
	회사에선 메이븐 서버 구축해돟은 회사가 있을 수도 있고
	중소기업쪽으로 가면 없을 수도 있다
---------------------------------------------------------------------------------------------------------------------------------------------------------
 mvn install:install-file –Dfile="C:\myProject\driver\ojdbc8.jar" -DgroupId=com.oracle –DartifactId=ojdbc8 -Dversion=18.3 -Dpackaging=jar

11g의 경우 ojdbc6 version 11.2.0.4

---------------------------------------------------------------------------------------------------------------------------------------------------------
@Service 	DAO
		OracleDAO	MySQLDAO 이런식으로 상속받아서 구현을 하겟다

	DAO를 클래스로 만들면 나중에 DB를 이전하거나 하면 통째로 뜯어고쳐야 하는 상황이 온다
	위와 같이 사용할 경우 인터페이스로 하는거고 아닐 경우 DAO를 클래스로 만들어도 된다

Service는 InsertService / UpdateService등 이런식으로 분리를 한다
	서비스를 하나 만들고 하나 통째로 상속받아서 가면 DAO와 일대일 대응잉여서 수정할려고 하면 서비스를 통째로 바꿔야한다

	제대로 만들려면 기능별로 분리를 해서 나가야 한다
	Service엔 DAO가 주입
	나중에 controller안에서 여러개를 주입 받을 수 있다

	예를 들어서 결제 시스템 -> 상품 확인 DAO / 결제DAO등 만들어야 한다

xml로 설정한것을 어노테이션으로 바꾸는
---------------------------------------------------------------------------------------------------------------------------------------------------------
프로그램은 젛대적으로 결합도르 낮추고 응집도를 올리기 위한 방향으로 
DI가 결합도를 낮추는 

스토리지 서버까지 해서 세대 연동하는
아마존 웹서비스가 회원가입을 하면 1년동안 무료다 -> 한사람이 최대 5년까지 가능
	-> 구글 계정이 최대 다섯개가 만들어져서
나중에 서버세팅할때 학원 컴퓨터로 세팅하면 안된다 -> 노트북이 있어야 한다

조별로 한명이 셋팅하면 된다

시스템을 개발하는것도 개발자고 시스템만 열심히 공부해서 가면 할게 없는
---------------------------------------------------------------------------------------------------------------------------------------------------------
제 4 강 Spring AOP
Aspect Oriented Programming 관심지향 프로그래밍

회원을 등록하고 가입하는게 코어기능

코어 기능하고 크로스커팅기능을 분리하자

※ 은행을 볼때 계좌이체 / 입출금 / 이자계산 -> 핵심관심

로그를 남겨놔서 나중에 문제가 생겼을때 찍어놓는 / 보안/ 트랜잭션 -> 횡단관심

핵심로직안에 계속 뭔가가 들어오면 나중에 다 바꿔야 하는 상황이 온다

트랜잭션때문에 자연스럽게 쓰게 되는데

★ AOP의 용어부터 외워야 책을 읽을 수 있다
▢ Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의하고 있다. 예를 들어 “메서드를 호출하기 전”(언제)에 “트랜잭션을 시작한다.
	”(공통기능)을 적용한다는 것을 정의하고 있다. 
▢ Joinpoint : Advice를 적용 가능한 지점을 의미한다. 메서드 호출, 필드 값 변경 등이 이에 해당한다. 
▢ Pointcut : Joinpoint의 부분 집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타낸다. 스프링에서는 
	정규표현식이나 AspectJ의 문법을 이용하여 Pointcut을 정의할 수 있다. 
		실제 적용될 곳
▢ Weaving : Advice를 핵심 로직 코드에 적용하는 것을 weaving이라고 한다. 즉 공통 코드를 핵심로직 코드에 삽입하는 것이 weaving이다. 
▢ Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 Aspect라고 한다. 트랜잭션이나 보안, 로깅 등이 Aspect의 좋은 예이다.

※ 위빙 방식 
	1. 컴파일 시에 위빙하기 
	AspectJ에서 사용하는 방식
 	핵심 로직을 구현한 자바 소스 코드를 컴파일 할 때에 알맞은 위치에 공통코드를 삽입
		-> 컴파일 하면 코드가 바껴있는
		=> 단점 개발자가 싫어한다 -> 내 소스가 바뀌어있어서 => 그래서 클래스 로딩시에 위빙이 나옴

※ 클래스 로딩 시에 위빙 
	원본 클래스 파일은 변경하지 않고 클래스를 로딩할때 JVM이 변경된 바이트 코드를 사용하도록 함으로써 AOP를 적용
LTW방식이라고도 한다 (Loading Time Weaver)

※ 런타임시에 위빙하기 
	프록시(대행자)를 이용해서 프록시를 통해서 대신 접근

	어드바이스를 이용해서 전과 후를 나눠서 

※ 스프링은 자체적으로 프록시 기반의 AOP를 지원

톰캣 jar파일 중에 instrument라는 라이브러리가 있는데 -> LTW기능이 있다
	WAS를 쓰면 그대로 되는

어떤 방법을 쓰든 스프링은 결과가 똑같고 실행되는 속도도 똑같아

원본을 건드리지 않고 가짜를 갖고 동작한다
=> 원본은 아에 안 건드리고 작업을 한다

대상 객체가 인터페이스를 구현하고 있지 않으면 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성한다

주입하는 것도 메서드마다 주입 바꿀때 너무 많이 바꾸게 된다 ->나름 객체지향 방법을 사용했지만 분리가 힘들다

그래서 이걸 한방에 해결해주는게 AOP -> 좀 변화 시킬 수 있다
AOP는 핵심로직에 관심사항이 들어가지 않는다

pointcut : 적용가능한 위치

기존꺼 안거드리는 방식 -. 설정 파일 만 바꾸면 전체가 바뀌는

dom.project.name.		board.domain
			board.service

			member.domain
			
			qnq.domain

설정에서 몇개 만들어놓으면 내가 원하는 부분에 정확히 걸 수 있는
=> 결론 AOP를 쓰면 핵심로직과 부수적인 관심사항과 분리를 했고 서로 영향을 안주는

비침투적인 방식 -> 결합도가 잘 안보여서
	=> 설정을 반드시 알아야 한다

joinpoint 클라이언트가 호출하는 모든 비즈니스 메서드로 포인트컷의 대상

※ pointcut 문법 
AspectJ의 pointcut 표현식
execution(리턴타입패턴 패키지경로패턴.클래스이름패턴.메서드이름패턴(파라미터패턴)

대부분은 excution 메서드


pointcut을 조합해야 하는 경우도 있다
	관리자의 어떤 메서드와 user의 메서드가 필요할때 내가 원하지 않는 메서드가 다 걸릴 수도 있으므로 
	&& || 연산자로 찍을 수 있다

※ 위빙
핵심관심 메서드가 호출될 때 어드바이스에 해당하는 욍단관심 메서드가 삽입되는 과정을 의미
크게 세가지가 있다
그중에 스프링은 런타임위빙(프록시)을 지원한다


throwing은 예외가 나오면 안나온다

around는 ProceedingJoinPoint을 사용하고 jointPoint.proceed() 앞뒤로 before after 형식이다
	다른 before나 그런애도 ProceedingJoinPoint를 가질 수 있다